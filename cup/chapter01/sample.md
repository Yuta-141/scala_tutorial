# 第01章
## 1.1　プログラマーとともに成長する言語

```
var capital = Map("US" -> "Washington", "France"->"Paris") //首都を導くMapをセットアップ
capital += ("Japan"->"Tokyo")// Japanを追加
println(capital("France")) 
``` 
 連想マップにより、簡潔に書ける。しかし、プログラムで使うマップの属性を細かく指定する必要がある場合も
Scalaではマップは言語構文ではなく、拡張、修正できるライブラリーになっている。
必要な時には細かい操作を加えられる。

Scalaは書きやすさと柔軟性を両立させる。
手軽に書ける単純性＆必要な時には拡張できる柔軟性

### 1.1.1 新しい型を作れる言語

Eric Raymond「伽藍(がらん)とバザール」
伽藍：建設に時間のかかる完璧な建物
バザール；日々修正、拡張される→オープンソースソフトウェアの比喩

Scala　not プログラマーが要請する全ての構文要素を１つの「完璧な」言語にまとめて提供
Scala yes そのような構文要素を組み立てるためのツールをプログラマーに与える。
* 例
オーバーフローせず、桁の上限をいくらでも大きくできる整数型を
必要とする
Scalaはライブラリークラスのscala.BigIntでそのような型を定義

+ ファイル（入力）
```
def factorial(x: BigInt): BigInt = if (x == 0) 1 else x * factorial(x -1)

println(factorial(10))
println(factorial(30))
```
+ 出力
```
$ scala sample.scala
Paris
3628800
265252859812191058636308480000000
```

今回はたまたま標準ライブラリにBigIntがあったが、なくても(Javaを使うなりして)作ることができる。

```
import java.math.BigInteger

def factorial(x: BigInteger): BigInteger =
if(x == BigInteger.ZERO)
    BigInteger.ONE
else
    x.multiply(factorial(x.subtract(BigInteger.ONE)))
```
## 1.1.2

# 1.2 Scalaがスケーラブルな理由
オブジェクト指向かつ関数型言語
最初の関数型言語はLisp
関数型言語は２つの発想の元導かれている
1. 関数を値として扱う
2. メソッドはどんな副作用も持ってはならない
引数をとり、結果値を返すという方法でのみ通信


# 1.3 Scalaを選ぶ理由
* 互換性
    - Javaとの共存
* 簡潔さ
    - Javaの半分以下のコード量
        1. Scalaはまじないのようなコード（;など）が不要
        2. Scalaの型推論
            -  型情報を反復する必要がない
        3. 書かなくて済むコード
            -   すでにライブラリに収められている。
            -   強力なライブラリーを定義するためのツールが多数搭載
* 高水準の抽出
    -   抽象度の高いコード、新しい制御構造を定義できる表現力
        +   複雑な構造を掌握する
        +   設計・利用するインターフェースの抽象度をあげることができる
* 高度な静的型付け
    -   簡潔性、柔軟性、検証可能性、安全性、ドキュメント性
        +   静的な型システムは、変数と式をそれが保持、計算する値の種類により分類
        +   検証可能な性質
            *   ある種のランタイムエラーが存在しないことを証明できる
            + しかし、今日の静的型システムではその他の種類のエラーは検出されない
                +   単体テストの代わりにはならないが、プログラムの性質確認のため必要な単体テストの数を減らす
                +   さらに単体テストは静的型付けの代わりにはならない
                    + エラーの存在は証明できるが、エラーの不在は証明できない
        +   安全なリファクタリング
            *   静的型システムは、ソースコード変更の際にセーフティネットを提供してくれる
        +   ドキュメント性
            *   静的データ型は、コンパイラーによって正しいかどうチェックされるプログラムドキュメントでもある
                +   コメントと違い古びることがない
# 1.4 Scalaの様々なルーツ
Scalaの設計は多くのプログラミング言語やプログラミング言語研究のアイディアに影響を受けている
-   Scalaの大きなイノベーションは主として構文要素の組み合わせ型にある

    -   JavaとC#の構文の多くを採用
        + これらはCとC++から構文の大半を借りている
    -   Smalltark,Rubyから、徹底したオブジェクトモデルを
    -   普遍的なネストの考え方はAlfol,Simula,Beta,gbeta
    -   メソッド呼び出しとフィールド選択での統一形式アクセスの原則はEiffelから
    -   関数型ぷうログラミングに対するアプローチは、SML,OCaml,F#などに近い
    -   Scala標準ライブラリに含まれる多くの高階関数はMLやHaskellにも含まれている
    -   Scalaの暗黙の型パラメータはHaskellの型クラスに触発されたもの
